<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml"><head><title>Tree (bam.Bam.Tree)</title><meta charset="utf-8"/><link rel="stylesheet" href="../../../odoc.support/odoc.css"/><meta name="generator" content="odoc 2.4.0"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><script src="../../../odoc.support/highlight.pack.js"></script><script>hljs.initHighlightingOnLoad();</script></head><body class="odoc"><nav class="odoc-nav"><a href="../index.html">Up</a> â€“ <a href="../../index.html">bam</a> &#x00BB; <a href="../index.html">Bam</a> &#x00BB; Tree</nav><header class="odoc-preamble"><h1>Module <code><span>Bam.Tree</span></code></h1><p>Module defining trees which is the main data-structure behind shrinking used by the <a href="../Gen/index.html"><code>Gen</code></a>. This module shoul be used only when defining a new runner for a new Test framework.</p></header><nav class="odoc-toc"><ul><li><a href="#tree">Tree</a><ul><li><a href="#searching-functions-as-trees">Searching functions as trees</a></li><li><a href="#a-monadic-interface">A monadic interface</a></li><li><a href="#merging-values">Merging values</a></li><li><a href="#forest">Forest</a></li><li><a href="#shrinking">Shrinking</a></li></ul></li></ul></nav><div class="odoc-content"><h2 id="tree"><a href="#tree" class="anchor"></a>Tree</h2><p>This module encodes a non-bounded branching tree. Values are generated lazily via the module <code>Seq</code>.</p><div class="odoc-spec"><div class="spec type anchored" id="type-t"><a href="#type-t" class="anchor"></a><code><span><span class="keyword">type</span> <span>'a t</span></span></code></div><div class="spec-doc"><p>Abstract representation of a tree.</p></div></div><div class="odoc-spec"><div class="spec type anchored" id="type-tree"><a href="#type-tree" class="anchor"></a><code><span><span class="keyword">type</span> <span>'a tree</span></span><span> = <span><span class="type-var">'a</span> <a href="#type-t">t</a></span></span></code></div><div class="spec-doc"><p>Convenient alias if <code>'a t</code> is shadowed.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-make"><a href="#val-make" class="anchor"></a><code><span><span class="keyword">val</span> make : <span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> <span><span>(<span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> <span class="xref-unresolved">Stdlib</span>.Seq.t</span>)</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> <a href="#type-t">t</a></span></span></code></div><div class="spec-doc"><p><code>make f root</code> returns a tree with root <code>root</code> and the children are recursively produced (lazily) with <code>f</code>.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-of_seq"><a href="#val-of_seq" class="anchor"></a><code><span><span class="keyword">val</span> of_seq : <span><span><span class="type-var">'a</span> <span class="xref-unresolved">Stdlib</span>.Seq.t</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> <a href="#type-t">t</a></span></span></code></div><div class="spec-doc"><p><code>of_seq seq root</code> returns a tree whose root is <code>root</code> and the children are generated via <code>seq</code>. Hence, if <code>seq</code> is not empty, the depth of the tree is <code>1</code>.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-root"><a href="#val-root" class="anchor"></a><code><span><span class="keyword">val</span> root : <span><span><span class="type-var">'a</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <span class="type-var">'a</span></span></code></div><div class="spec-doc"><p><code>root tree</code> returns the root of the tree.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-map"><a href="#val-map" class="anchor"></a><code><span><span class="keyword">val</span> map : <span><span>(<span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> <span class="type-var">'b</span>)</span> <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'a</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'b</span> <a href="#type-t">t</a></span></span></code></div><div class="spec-doc"><p><code>map f tree</code> maps <code>f</code> to all the elements of the tree. The merge function is reset to <code>Seq.append</code>. There is no automatic way to preserve the merge behavior with <code>map</code>. However, you can save the previous behavior with <code>get_merge</code> and set a new behavior with <code>with_merge</code>.</p></div></div><h3 id="searching-functions-as-trees"><a href="#searching-functions-as-trees" class="anchor"></a>Searching functions as trees</h3><div class="odoc-spec"><div class="spec value anchored" id="val-binary_search"><a href="#val-binary_search" class="anchor"></a><code><span><span class="keyword">val</span> binary_search : <span><span class="label">initial</span>:<span class="xref-unresolved">Z</span>.t <span class="arrow">&#45;&gt;</span></span> <span><span class="label">origin</span>:<span class="xref-unresolved">Z</span>.t <span class="arrow">&#45;&gt;</span></span> <span>unit <span class="arrow">&#45;&gt;</span></span> <span><span class="xref-unresolved">Z</span>.t <a href="#type-t">t</a></span></span></code></div><div class="spec-doc"><p><code>binary_search ~initial ~origin</code> implements a binary search enumerating elements. Elements are guaranteed to be in the interval <code>origin;initial</code>.</p><p>Note: If <code>initial &lt; origin</code>, it returns a tree with the single node <code>origin</code>.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-fractional_search"><a href="#val-fractional_search" class="anchor"></a><code><span><span class="keyword">val</span> fractional_search : 
  <span><span class="optlabel">?exhaustive_search_digits</span>:int <span class="arrow">&#45;&gt;</span></span>
  <span><span class="optlabel">?precision_digits</span>:int <span class="arrow">&#45;&gt;</span></span>
  <span><span class="label">initial</span>:float <span class="arrow">&#45;&gt;</span></span>
  <span><span class="label">origin</span>:float <span class="arrow">&#45;&gt;</span></span>
  <span>unit <span class="arrow">&#45;&gt;</span></span>
  <span>float <a href="#type-t">t</a></span></span></code></div><div class="spec-doc"><p><code>fractional_search ?exhaustive_search_digits ?precision_digits
    ~initial ~origin ()</code> returns a tree of depth one where the root is <code>initial</code> and children are ordered by the prefix ordering (modulo float representations) starting with <code>origin</code>. The children are always float between <code>origin</code> and <code>initial</code> starting with floats with few digits.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-linear_search"><a href="#val-linear_search" class="anchor"></a><code><span><span class="keyword">val</span> linear_search : <span><span class="label">initial</span>:<span class="xref-unresolved">Z</span>.t <span class="arrow">&#45;&gt;</span></span> <span><span class="label">origin</span>:<span class="xref-unresolved">Z</span>.t <span class="arrow">&#45;&gt;</span></span> <span>unit <span class="arrow">&#45;&gt;</span></span> <span><span class="xref-unresolved">Z</span>.t <a href="#type-t">t</a></span></span></code></div><div class="spec-doc"><p><code>linear_search</code> returns a tree of depth 1 whose <code>root</code> is <code>initial</code> and children are the number from <code>origin</code> included to <code>initial</code> excluded.</p></div></div><h3 id="a-monadic-interface"><a href="#a-monadic-interface" class="anchor"></a>A monadic interface</h3><div class="odoc-spec"><div class="spec value anchored" id="val-return"><a href="#val-return" class="anchor"></a><code><span><span class="keyword">val</span> return : <span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> <a href="#type-t">t</a></span></span></code></div><div class="spec-doc"><p><code>return value</code> returns a tree containing a single node with <code>value</code>.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-bind"><a href="#val-bind" class="anchor"></a><code><span><span class="keyword">val</span> bind : <span><span><span class="type-var">'a</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span>(<span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'b</span> <a href="#type-t">t</a></span>)</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'b</span> <a href="#type-t">t</a></span></span></code></div><div class="spec-doc"><p><code>bind tree f</code> returns a tree where <code>f</code> is applied (lazily) to all the values of <code>tree</code>. Since <code>f</code> returns itself a tree, <code>bind</code> must be able to merge values of <code>tree</code> with the ones produced by <code>f</code>. This can be done via the merging process specified by the tree returned by <code>f</code>.</p></div></div><div class="odoc-spec"><div class="spec module anchored" id="module-Syntax"><a href="#module-Syntax" class="anchor"></a><code><span><span class="keyword">module</span> <a href="Syntax/index.html">Syntax</a></span><span> : <span class="keyword">sig</span> ... <span class="keyword">end</span></span></code></div></div><h3 id="merging-values"><a href="#merging-values" class="anchor"></a>Merging values</h3><p>By using <code>bind</code>, one needs to be able to merge sequences of trees. To understand why, let's give an informal definition of <code>bind</code>:</p><pre class="language-ocaml"><code>let rec bind tree f =
   let {root;children=left} = tree in
   (* children : 'a t Seq.t *)
   let {root; children=right} f root in
   (* How should we combine the sequence of trees denotes by [left] and [right]? *)</code></pre><p>A natural way to merging them as denoted by the variable names is to use <code>Seq.append</code>. However, this is an arbitrary choice. Libraries using this module may redefine the default merging procedure to enable more complex behaviors.</p><p>Even though <code>Seq.append</code> is arbitrary, in practice it leads to predictable and easy to unerstand behaviors.</p><p>Notice that in the definition above, there are two trees, hence maybe two different merging behaviors. However, by typing, only one is allowed: the one resulting of the application of <code>f root</code>.</p><p>The type of the <code>merge</code> prevents <code>'a t</code> to be an applicative functor.</p><div class="odoc-spec"><div class="spec value anchored" id="val-with_merge"><a href="#val-with_merge" class="anchor"></a><code><span><span class="keyword">val</span> with_merge : 
  <span><span class="label">merge</span>:<span>(<span><span><span><span class="type-var">'a</span> <a href="#type-t">t</a></span> <span class="xref-unresolved">Stdlib</span>.Seq.t</span> <span class="arrow">&#45;&gt;</span></span> <span><span><span><span class="type-var">'a</span> <a href="#type-t">t</a></span> <span class="xref-unresolved">Stdlib</span>.Seq.t</span> <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'a</span> <a href="#type-t">t</a></span> <span class="xref-unresolved">Stdlib</span>.Seq.t</span>)</span> <span class="arrow">&#45;&gt;</span></span>
  <span><span><span class="type-var">'a</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span>
  <span><span class="type-var">'a</span> <a href="#type-t">t</a></span></span></code></div><div class="spec-doc"><p><code>with_merge ~merge tree</code> sets the merging behavior as <code>merge</code>.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-get_merge"><a href="#val-get_merge" class="anchor"></a><code><span><span class="keyword">val</span> get_merge : 
  <span><span><span class="type-var">'a</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span>
  <span><span><span><span class="type-var">'a</span> <a href="#type-t">t</a></span> <span class="xref-unresolved">Stdlib</span>.Seq.t</span> <span class="arrow">&#45;&gt;</span></span>
  <span><span><span><span class="type-var">'a</span> <a href="#type-t">t</a></span> <span class="xref-unresolved">Stdlib</span>.Seq.t</span> <span class="arrow">&#45;&gt;</span></span>
  <span><span><span class="type-var">'a</span> <a href="#type-t">t</a></span> <span class="xref-unresolved">Stdlib</span>.Seq.t</span></span></code></div><div class="spec-doc"><p><code>get_merge tree</code> returns the merge function for this tree.</p></div></div><h3 id="forest"><a href="#forest" class="anchor"></a>Forest</h3><div class="odoc-spec"><div class="spec module anchored" id="module-Forest"><a href="#module-Forest" class="anchor"></a><code><span><span class="keyword">module</span> <a href="Forest/index.html">Forest</a></span><span> : <span class="keyword">sig</span> ... <span class="keyword">end</span></span></code></div><div class="spec-doc"><p>A forest can be considered as a non-empty sequence of trees. The functions declared in this module transposed naturally the functions provided on <code>tree</code>.</p></div></div><h3 id="shrinking"><a href="#shrinking" class="anchor"></a>Shrinking</h3><div class="odoc-spec"><div class="spec value anchored" id="val-shrink"><a href="#val-shrink" class="anchor"></a><code><span><span class="keyword">val</span> shrink : <span><span>(<span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> <span><span>(<span class="type-var">'ok</span>, <span class="type-var">'err</span>)</span> <span class="xref-unresolved">Stdlib</span>.Result.t</span>)</span> <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'a</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <span class="type-var">'a</span></span></code></div><div class="spec-doc"><p><code>shrink tree f</code> returns a value <code>a</code> that has the following specification:</p><ul><li><code>f a = Error _</code></li></ul><ul><li><code>path(a,tree.root) = true</code></li></ul><ul><li>forall v, if <code>v \in path(a, tree.root)</code> then <code>f v = Error _</code></li></ul><ul><li>if <code>v' = Left(v)</code> and <code>v \in path(a, tree.root)</code> then <code>f v = Ok _</code></li></ul><p>Assuming that <code>f tree.root</code> is <code>Error _</code>.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-crunch"><a href="#val-crunch" class="anchor"></a><code><span><span class="keyword">val</span> crunch : <span>int <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'a</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> <a href="#type-t">t</a></span></span></code></div><div class="spec-doc"><p><code>crunch i tree</code> returns a tree where the row <code>i</code> is merged with row <code>i-1</code>. Hence, when <code>i &lt;= 1</code>, this is the identity function.</p></div></div></div></body></html>
