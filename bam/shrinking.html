<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml"><head><title>shrinking (bam.shrinking)</title><meta charset="utf-8"/><link rel="stylesheet" href="../odoc.support/odoc.css"/><meta name="generator" content="odoc 2.4.0"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><script src="../odoc.support/highlight.pack.js"></script><script>hljs.initHighlightingOnLoad();</script></head><body class="odoc"><nav class="odoc-nav"><a href="index.html">Up</a> â€“ <a href="index.html">bam</a> &#x00BB; shrinking</nav><header class="odoc-preamble"><h2 id="shrinking"><a href="#shrinking" class="anchor"></a>A primer on shrinking</h2><p>Shrinking is an important part of the <code>Bam</code> library. Even though the standard library aims at producing good enough counter-examples, it may not be sufficient for complex generators. To write good shrinking strategies, it is important to understand how shrinking works in <code>Bam</code>, and this page is the perfect place for that.</p><p>This page will help you at understanding how <a href="Bam/Std/index.html#val-bind"><code>Bam.Std.bind</code></a> or <a href="Bam/Std/index.html#val-crunch"><code>Bam.Std.crunch</code></a> functions work for example.</p><p>The type of a generator can be defined as:</p><pre class="language-ocaml"><code>type 'a t = unit -&gt; 'a Tree.t</code></pre><p>The idea is that the root of the tree is the actual generated value while the children will contain smaller values for the shrinker.</p><p>Such a tree can be represented in the following way:</p><pre class="language-ocaml"><code>type 'a tree =
  {root : 'a;
   children : 'a tree Seq.t
  }</code></pre><p>Using a sequence enables to load the values for the shrinking only when necessary. As a consequence, it also means that the branching factor is not bounded. Generators defined by the library try to ensure the branching factor does not explode to be sure the shrinking won't take too much time.</p><p>Similarly to the branching factor, the depth is not bounded. Again, the generators defined by the library try to ensure the depth does not explode.</p><p>The main building block to make the library working is about giving a monadic interface for the generators.</p></header><nav class="odoc-toc"><ul><li><a href="#defining-a-monadic-interface">Defining a monadic interface</a></li><li><a href="#generate-integers">Generate integers</a></li><li><a href="#a-side-effect-issue">A side-effect issue</a></li><li><a href="#generators-should-be-pure">Generators should be pure</a></li></ul></nav><div class="odoc-content"><h3 id="defining-a-monadic-interface"><a href="#defining-a-monadic-interface" class="anchor"></a>Defining a monadic interface</h3><p>Let's first tackle how we can give a monadic interface for the <code>'a
tree</code> datatype. For the <code>return</code>, this is easy:</p><pre class="language-ocaml"><code>let return root = {root; children = Seq.empty}</code></pre><p>But for the <code>bind</code> function, this is relatively different:</p><pre class="language-ocaml"><code>let rec bind tree f =
  let root_tree = f tree in
  let children_trees = Seq.map (fun tree -&gt; bind tree f) tree.children in
  let root = root_tree.root in
  (* Now we have two sequences for the children namely root_tree.children
     and cihldren_trees. How should we combine them? *)
  {root;
   children = Seq.append root_tree.children children_trees}</code></pre><p>As mentioned in the commentaire of the function, there is something quite arbitrary in the way we combine the two different sequence of trees. Using <code>Seq.append</code> is the most obvious choice, but it may be interesting to have more strategies. This is what the merge-related functions do: Allowing to define a custom way to combine those children.</p><p>Now that the <code>bind</code> function is defined on trees, we can tackle the <code>bind</code> function for generators:</p><pre class="language-ocaml"><code>let bind gen f = fun () -&gt;
    let tree = gen () in
    bind tree (fun x -&gt; f x ())    </code></pre><p>While such a function is well-typed, it does not behave exactly as we would like. To understand why, let's try to define a first generator for integers.</p><h3 id="generate-integers"><a href="#generate-integers" class="anchor"></a>Generate integers</h3><p>Assuming we want to define a generator for small integers. One could define a simple tree where the root is the value drawn and the children are all the value from <code>0</code> up to <code>value-1</code>.</p><pre class="language-ocaml"><code>let gen_int : max:int = fun () -&gt;
  let root = Random.int max in
  let children = Seq.ints 0 |&gt; Seq.take root in
  {root;children}</code></pre><p>In practice, this function is very inefficient for larger integers. In practice, a binary search is used (see <code>Tree.binary_search</code>).</p><h3 id="a-side-effect-issue"><a href="#a-side-effect-issue" class="anchor"></a>A side-effect issue</h3><p>Let's try to use this newly defined generator to define a generator for pair of integers:</p><pre class="language-ocaml"><code>let gen_pair () =
  bind (gen_int ~max:10 ()) (fun x -&gt;
    bind (gen_int ~max:20 ()) (fun y -&gt;
      return (x,y)))</code></pre><p>This generator might return as a root value something such as <code>(3,5)</code>. Now, what do you think the children value will be?</p><p>Unexpectedly, if we inspect children values we will see something such as: <code>(2,15)</code>, <code>(1,7)</code>, <code>(0,4)</code>, <code>(2;19)</code>, ... What we can observe is that the tree generated will contain smaller values for the first component, but not for the second component. The reason is actually easy: This is because the function <code>bind</code> for <code>tree</code> calls <code>f</code> on smaller values of the first tree (generated by <code>gen_int ~max:10
()</code>). The function <code>f</code> calls (gen_int ~max:20 ()) on each values generated by the first tree, effectively drawing new values.</p><p>Such a problem is well-known and this is why, some library recommend to not use <code>bind</code>. For example, another way to define a generator for pairs could be:</p><pre class="language-ocaml"><code>let gen_pair () =
    let x = gen_int ~max:10 () in
    let y = gen_int ~max:10 () in
    let children = (* Define a shrinker for pairs. *) assert false in
    {root = (x,y); children}</code></pre><p>A library offering Integrated shrinking must consequently defines a shrinker for pairs. There are many functions possible.</p><p>This has two disadvantages:</p><ul><li>It can be hard to predict what will be the shrinking strategy</li></ul><ul><li>The library must define many basic combinators to overcome this issue</li></ul><p>Instead, this library makes the choice that having few building blocks such as <code>bind</code> would be better:</p><ul><li>It increases predictability since understand the <code>bind</code> enables to understand most of the shrinking strategies offered by this library</li></ul><ul><li>It enables to have a very light trusted kernel</li></ul><h3 id="generators-should-be-pure"><a href="#generators-should-be-pure" class="anchor"></a>Generators should be pure</h3><p>Actually the solution to this problem is relatively simple and holds in two steps:</p><p>Step 1: Change the type of a generator so that there is no more implicit side-effects</p><pre class="language-ocaml"><code>type 'a t = Random.state -&gt; 'a Tree.t</code></pre><p>Step 2: Change the bind function to split the state into two independent states</p><pre class="language-ocaml"><code>let bind gen f = fun () -&gt;
    let rs_left, rs_right = Random.split rs in    
    let tree = gen rs_left in
    bind tree (fun x -&gt; f x rs_right)    </code></pre></div></body></html>
