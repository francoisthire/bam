<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml"><head><title>shrinking (bam.shrinking)</title><meta charset="utf-8"/><link rel="stylesheet" href="../odoc.support/odoc.css"/><meta name="generator" content="odoc 2.4.2"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><script src="../odoc.support/highlight.pack.js"></script><script>hljs.initHighlightingOnLoad();</script></head><body class="odoc"><nav class="odoc-nav"><a href="index.html">Up</a> â€“ <a href="index.html">bam</a> &#x00BB; shrinking</nav><header class="odoc-preamble"><h2 id="shrinking"><a href="#shrinking" class="anchor"></a>A primer on shrinking</h2><p>Shrinking is an integral part of the <code>Bam</code> library, focused on enhancing the generation of counterexamples. While the standard library aims to produce adequate counterexamples, it may encounter limitations with more complex generators. Understanding the mechanisms of shrinking in <code>Bam</code> is crucial for using and developing effective shrinking strategies. This documentation provides insights into these mechanisms.</p><p>The functions <a href="Bam/Std/index.html#val-bind"><code>Bam.Std.bind</code></a> and <a href="Bam/Std/index.html#val-crunch"><code>Bam.Std.crunch</code></a> are examples of function within <code>Bam</code> that facilitate the shrinking process. Their operational details and applications are explained in subsequent sections.</p><p>A general idea for defining generators with internal shrinking is to use the following data-type:</p><pre class="language-ocaml"><code>type 'a t = unit -&gt; 'a Tree.t</code></pre><p>In this structure, the root of the tree represents the original generated value, and the child nodes contain smaller values for the shrinker to use in the process of shrinking.</p><p>The structure of a tree within the <code>Bam</code> library is defined as follows:</p><pre class="language-ocaml"><code>type 'a tree =
  {root : 'a;
   children : 'a tree Seq.t
  }</code></pre><p>This definition uses a sequence <code>Seq.t</code> to manage the values for shrinking, allowing these values to be computed only when needed. This approach implies that the branching factor of the tree is unbounded. Library-defined generators are designed to prevent excessive branching, ensuring that the shrinking process remains time-efficient.</p><p>Similarly, the depth of the tree is also unbounded. However, the generators in the library are constructed to avoid excessive depth, maintaining efficiency in the shrinking process.</p><p>A key aspect of the library's functionality is providing a monadic interface for the generators.</p></header><nav class="odoc-toc"><ul><li><a href="#defining-a-monadic-interface">Defining a monadic interface</a></li><li><a href="#generate-integers">Generate integers</a></li><li><a href="#a-side-effect-issue">A side-effect issue</a></li><li><a href="#generators-should-be-pure">Generators should be pure</a></li></ul></nav><div class="odoc-content"><h3 id="defining-a-monadic-interface"><a href="#defining-a-monadic-interface" class="anchor"></a>Defining a monadic interface</h3><p>The process of implementing a monadic interface for the <code>'a tree</code> data type begins with the return function. Defining return is straightforward:</p><pre class="language-ocaml"><code>let return root = {root; children = Seq.empty}</code></pre><p>However, the implementation of the bind function is more complex:</p><pre class="language-ocaml"><code>let rec bind tree f =
  let root_tree = f tree in
  let children_trees = Seq.map (fun tree -&gt; bind tree f) tree.children in
  let root = root_tree.root in
  (* Now we have two sequences for the children namely root_tree.children
     and cihldren_trees. How should we combine them? *)
  {root;
   children = Seq.append root_tree.children children_trees}</code></pre><p>The function's comment highlights a decision point: the method used to combine two sequences of trees, <code>root_tree.children</code> and <code>children_trees</code>. While <code>Seq.append</code> is a straightforward option, the possibility of employing alternative strategies exists. The library's merge-related functions facilitate the definition of custom methods for combining these child sequences. One example where this strategy has an effect is in the shrinker for pairs (2-tuples). The described strategy initially shrinks the left component and then the right component. If we invert the order of the arguments given to <code>Seq.append</code>, it would first shrink the right component and then the left component.</p><p>With the definition of the bind function for trees established, the next step is to implement the bind function for generators:</p><pre class="language-ocaml"><code>let bind gen f = fun () -&gt;
    let tree = gen () in
    bind tree (fun x -&gt; f x ())    </code></pre><p>Although this implementation is correctly typed, its practical behavior does not align entirely with the desired outcome. This discrepancy becomes evident when attempting to define a basic generator for integers.</p><h3 id="generate-integers"><a href="#generate-integers" class="anchor"></a>Generate integers</h3><p>Consider the task of creating a generator for small integers. A straightforward approach might involve constructing a tree where the root is the drawn value, and the children are all values from <code>0</code> to <code>value-1</code>.</p><pre class="language-ocaml"><code>let gen_int : max:int = fun () -&gt;
  let root = Random.int max in
  let children = Seq.ints 0 |&gt; Seq.take root in
  {root;children}</code></pre><p>Do note that this generator is naive because the shrinking approach is not efficient and proves to be highly inefficient for larger integer values. <code>Bam</code> generators use a more efficient method using dichotomy as illustrated in <code>Tree.binary_search</code>.</p><h3 id="a-side-effect-issue"><a href="#a-side-effect-issue" class="anchor"></a>A side-effect issue</h3><p>The issue of side effects becomes evident when using the previously defined generator to create a generator for pairs of integers:</p><pre class="language-ocaml"><code>let gen_pair () =
  bind (gen_int ~max:10 ()) (fun x -&gt;
    bind (gen_int ~max:20 ()) (fun y -&gt;
      return (x,y)))</code></pre><p>For instance, this generator might yield a root value like (3,5). However, the children values produced can be unexpected, such as <code>(2,15)</code>, <code>(1,7)</code>, <code>(0,4)</code>, <code>(2,19)</code>, ... and so on. These values reveal that while the first component of the tree shows decreasing values, the second component does not follow this pattern. The underlying reason is that the bind function for the tree applies the function f to the smaller values of the first tree (created by <code>gen_int
~max:10 ()</code>). Each time <code>f</code> is called, it invokes <code>gen_int ~max:20 ()</code>, generating new values for the second component.</p><p>This issue is well-known in the context of generators, leading some libraries to advise against using bind for such scenarios. An alternative approach to defining a generator for pairs might look like this:</p><pre class="language-ocaml"><code>let gen_pair () =
    let x = gen_int ~max:10 () in
    let y = gen_int ~max:10 () in
    let children = (* Define a shrinker for pairs. *) assert false in
    {root = (x,y); children}</code></pre><p>Here, <code>x</code> and <code>y</code> are generated independently, and a specific shrinker for pairs needs to be defined to handle the shrinking process appropriately.</p><p>Integrated shrinking within a library requires the establishment of a shrinker for pairs, and there can be several possible functions to achieve this. However, this approach has its drawbacks:</p><ul><li>Predicting the shrinking strategy can be challenging.</li><li>The library must implement a variety of basic combinators to address this limitation.</li></ul><p>To mitigate these issues, the <code>bam</code> library opts for a simpler approach, relying on a few foundational building blocks like <code>bind</code>. This choice offers two primary advantages:</p><ul><li>Improved predictability: Understanding the <code>bind</code> function is key to grasping most of the shrinking strategies employed in this library.</li></ul><ul><li>A more streamlined and reliable core (&quot;trusted kernel&quot;).</li></ul><h3 id="generators-should-be-pure"><a href="#generators-should-be-pure" class="anchor"></a>Generators should be pure</h3><p>Addressing the aforementioned problem involves two main steps:</p><p>Step 1: Modify the generator's type to eliminate implicit side-effects:</p><pre class="language-ocaml"><code>type 'a t = Random.state -&gt; 'a Tree.t</code></pre><p>Step 2: Revise the bind function to split the state into two independent states:</p><pre class="language-ocaml"><code>let bind gen f = fun () -&gt;
    let rs_left, rs_right = Random.split rs in    
    let tree = gen rs_left in
    bind tree (fun x -&gt; f x rs_right)    </code></pre><p>These changes ensure that the generation process remains pure, with side effects being explicitly managed through the use of distinct random states.</p><p>This primer is incomplete and will be completed in the future.</p></div></body></html>
